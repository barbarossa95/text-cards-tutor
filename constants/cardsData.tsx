export const cardsData = [
  {
    question: "Типы данных в JavaScript (JS)",
    answer:
      "В JavaScript существует 7 основных типов данных:\n* **Примитивные:** `Number`, `String`, `Boolean`, `Null`, `Undefined`, `Symbol`, `BigInt`\n* **Ссылочные:** `Object`, `Array`, `Function`\n**Ссылки для детального изучения:**\n* [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures) \n* [https://javascript.info/types](https://javascript.info/types)",
  },
  {
    question: "Типы данных в TypeScript (TS)",
    answer:
      "TypeScript расширяет типы данных JavaScript, добавляя статическую типизацию, что позволяет лучше контролировать и отлавливать ошибки на ранних этапах разработки:\n* **Примитивные:** `number`, `string`, `boolean`, `null`, `undefined`, `symbol`, `bigint`\n* **Ссылочные:** `object`, `array`, `function`, `interface`, `class`, `enum` \n* **Дополнительные:** `any`, `unknown`, `void`, `never`\n```\n- number для любых чисел: целочисленных или чисел с плавающей точкой; \n- bigint для целых чисел произвольной длины.\n- string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.\n- boolean для true/false.\n- null для неизвестных значений – отдельный тип, имеющий одно значение null.\n- undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.\n- object для более сложных структур данных.\n- symbol для уникальных идентификаторов.\n```\n**Ссылки для детального изучения:**\n* [https://www.typescriptlang.org/docs/handbook/basic-types.html](https://www.typescriptlang.org/docs/handbook/basic-types.html)\n* [https://www.typescriptlang.org/docs/handbook/advanced-types.html](https://www.typescriptlang.org/docs/handbook/advanced-types.html)",
  },
  {
    question: "Классовые компоненты в React",
    answer:
      "Классовые компоненты в React предоставляют **state** (состояние) и **lifecycle methods** (методы жизненного цикла) для управления состоянием и поведением компонентов. \n**Ссылки для детального изучения:**\n* [https://ru.reactjs.org/docs/react-component.html](https://ru.reactjs.org/docs/react-component.html)\n* [https://ru.reactjs.org/docs/state-and-lifecycle.html](https://ru.reactjs.org/docs/state-and-lifecycle.html)",
  },
  {
    question: "Преобразования типов в TS",
    answer:
      "В TypeScript для преобразования типов используется оператор `as` (типовое утверждение) или специальные функции для преобразования типов.\n**Ссылки для детального изучения:**\n* [https://www.typescriptlang.org/docs/handbook/type-assertions.html](https://www.typescriptlang.org/docs/handbook/type-assertions.html)\n* [https://www.typescriptlang.org/docs/handbook/type-guards.html](https://www.typescriptlang.org/docs/handbook/type-guards.html)",
  },
  {
    question: "Замыкания",
    answer:
      "Замыкание - это функция, которая помнит свой лексический контекст (переменные, доступные в момент ее создания) даже после того, как функция завершает свое выполнение.\nВ глобальном контексте выполнения (за пределами каких-либо функций), this ссылается на глобальный объект вне зависимости от использования в строгом или нестрогом режиме.\nВ пределах функции значение this зависит от того, каким образом вызвана функция:\n- Простой вызов - В этом случае значение this не устанавливается вызовом. Так как этот код написан не в строгом режиме, значением this всегда должен быть объект, по умолчанию - глобальный объект. В строгом режиме, значение this остается тем значением, которое было установлено в контексте исполнения. Если такое значение не определено, оно остается undefined. Для того что бы передать значение this от одного контекста другому необходимо использовать call или apply\n- В стрелочных функциях, this привязан к окружению, в котором была создана функция. В глобальной области видимости, this будет указывать на глобальный объект.\n- Когда функция вызывается как метод объекта, используемое в этой функции ключевое слово this принимает значение объекта, по отношению к которому вызван метод.\n**Ссылки для детального изучения:**\n* [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)\n* [https://javascript.info/closure](https://javascript.info/closure)",
  },
  {
    question: "Разница const, let и var",
    answer:
      "* **`var`:** Область видимости - функциональная. Переменные `var` могут быть переопределены в той же области видимости.\n* **`let`:** Область видимости - блочная. Переменные `let` не могут быть переопределены в той же области видимости. \n* **`const`:** Область видимости - блочная. Переменные `const` должны быть инициализированы при объявлении и не могут быть переопределены.\n**Ссылки для детального изучения:**\n* [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var)\n* [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let)\n* [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const)",
  },
  {
    question: "Стрелочные функции в JS",
    answer:
      "Стрелочные функции предоставляют более краткий синтаксис для создания функций в JavaScript:\n* **Особенности:**  \n  * отсутствует `this`\n  * отсутствует переменная `arguments`, вместо этого все аргументы можно получить через конструкцию `...args`\n**Ссылки для детального изучения:**\n* [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)\n* [https://javascript.info/arrow-functions](https://javascript.info/arrow-functions)",
  },
  {
    question: "Контекст в React",
    answer:
      "Контекст React - это механизм для передачи данных по всему дереву компонентов React без необходимости явного прохождения их через пропсы на каждом уровне.\n**Ссылки для детального изучения:**\n* [https://ru.reactjs.org/docs/context.html](https://ru.reactjs.org/docs/context.html)",
  },
  {
    question: "Порталы в React",
    answer:
      "Порталы React - это способ рендеринга дочернего компонента в другой DOM-узел, отличный от родительского компонента.\n**Ссылки для детального изучения:**\n* [https://ru.reactjs.org/docs/portals.html](https://ru.reactjs.org/docs/portals.html)",
  },
  {
    question: "promises",
    answer:
      "Промис — это объект, который может вернуть одно значение в будущем: либо выполненное значение, либо причина, по которой оно не было выполнено (например, произошла ошибка сети). \nPromise в JavaScript — это объект, который представляет результат асинхронной операции. Он может находиться в одном из трёх состояний: pending (ожидание), fulfilled (выполнено) и rejected (отклонено). Fulfilled означает, что операция завершилась успешно, а rejected — что произошла ошибка. Это удобный способ работы с асинхронным кодом и упрощает обработку результатов таких операций. 4 состояния:\n* Ожидание — начальное состояние промиса. Результата промиса неизвестен, поскольку операция не завершена.\n* Выполнено — асинхронная операция выполнена, имеется результат.\n* Отклонено — асинхронная операция не выполнена, имеется причина.\n- Завершено — выполнено или отклонено.",
  },
  {
    question: "Async/await",
    answer:
      "Async/await — относительно новый способ написания асинхронного (неблокирующего) кода в JS. Им оборачивают промис использование ключевого слова «async» перед функцией заставляет ее возвращать промис Await ожидает завершения выражения справа, чтобы вернуть его значение перед выполнением следующей строчки кода.",
  },
  {
    question: "Event Loop",
    answer:
      '**Event Loop: Microtasks and Macrotasks**  \nВ JavaScript **Event Loop** управляет порядком выполнения асинхронного кода, разделяя задачи на **микрозадачи (microtasks)** и **макрозадачи (macrotasks)**.  \n**Макрозадачи** — это крупные операции, такие как `setTimeout`, `setInterval`, `I/O`, рендеринг в браузере или события (например, `click`). Они попадают в очередь макрозадач и выполняются по одной после завершения текущего синхронного кода и всех микрозадач.  \n**Микрозадачи** — это небольшие операции с высоким приоритетом, например, `Promise.then/catch/finally`, `queueMicrotask` или `MutationObserver`. Они выполняются сразу после текущего синхронного кода, но **перед** следующей макрозадачей. Event Loop обрабатывает **всю очередь микрозадач** перед переходом к макрозадачам.  \n**Пример:**  \n```javascript\nconsole.log("Start");\n\nsetTimeout(() => console.log("Timeout"), 0); // Макрозадача\nPromise.resolve().then(() => console.log("Promise")); // Микрозадача\n\nconsole.log("End");\n```\n**Вывод:**  \n```\nStart → End → Promise → Timeout\n```  \nСначала выполняется синхронный код, затем микрозадачи (`Promise`), а потом макрозадачи (`setTimeout`).  \nПонимание этого механизма помогает избегать неочевидных багов и писать более предсказуемый асинхронный код.',
  },
  {
    question: "Каррирование функций",
    answer:
      "Каррирование - это техника преобразования функции, которая принимает несколько аргументов, в последовательность функций, каждая из которых принимает один аргумент.  \nКак это работает: \n* Функция, принимающая несколько аргументов, преобразуется в функцию, которая принимает только один аргумент. \n* Эта функция возвращает другую функцию, которая принимает следующий аргумент, и так далее. \n* Когда все аргументы получены, выполняется исходная функция.\nПреимущества:\n* Повышенная гибкость: Каррирование позволяет создавать частично примененные функции, которые можно использовать повторно с разными аргументами. \n* Улучшенная читаемость: Код может стать более понятным, особенно при использовании сложных функций с множеством аргументов. \n* Функциональное программирование: Каррирование является фундаментальным концептом в функциональном программировании, позволяя работать с функциями как с данными.\nПримеры:\n```\n// Исходная функция\nfunction add(x, y) {\n  return x + y;\n}\n\n// Каррированная версия\nfunction curriedAdd(x) {\n  return function (y) {\n    return x + y;\n  };\n}\n\nconst add5 = curriedAdd(5); // Создаем частично примененную функцию\nconsole.log(add5(3)); // Вывод: 8\n\n// Другой пример с использованием библиотеки Ramda\nconst add = require('ramda').add;\nconst add5 = add(5);\nconsole.log(add5(3)); // Вывод: 8 \n```\n**Ссылки для детального изучения:**\n* [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#currying](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#currying)\n* [https://javascript.info/currying-partial-application](https://javascript.info/currying-partial-application)\n* [https://lodash.com/docs/4.17.15#curry](https://lodash.com/docs/4.17.15#curry)  (Библиотека Lodash)\n* [https://ramdajs.com/docs/#curry](https://ramdajs.com/docs/#curry) (Библиотека Ramda)",
  },
  {
    question: "Generics в TypeScript",
    answer:
      "Generics - это мощная концепция в TypeScript, которая позволяет создавать гибкие и повторно используемые компоненты кода, работающие с различными типами данных.\nКак это работает:\n* Параметризация: Generics позволяют вам определить \"местозаполнитель\" для типа, который будет заполнен конкретным типом при использовании компонента.\n* Типизация: TypeScript использует информацию о типе, чтобы гарантировать правильное использование компонентов, даже если реальный тип данных не известен до момента компиляции.\nПримеры:\n```\n// Функция с generic-параметром T\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n\n// Использование функции с разными типами\nconsole.log(identity<number>(10)); // T - number\nconsole.log(identity<string>('Hello')); // T - string\nconsole.log(identity<{ name: string }>({ name: 'Alice' })); // T - { name: string }\n\n// Интерфейс с generic-параметром T\ninterface Container<T> {\n  value: T;\n}\n\n// Использование интерфейса с разными типами\nconst numberContainer: Container<number> = { value: 10 };\nconst stringContainer: Container<string> = { value: 'Hello' };\n```\n**Преимущества:**\n* Повторное использование: Generics позволяют создавать функции, классы и интерфейсы, которые могут работать с различными типами данных, делая ваш код более универсальным.\n* Типовая безопасность: TypeScript может проверять типы во время компиляции, гарантируя, что код работает правильно с различными типами данных.\n* Улучшенная читаемость: Generics делают ваш код более понятным, поскольку вы явно указываете, с какими типами данных работает код.\n**Ссылки для детального изучения:**\n* [https://www.typescriptlang.org/docs/handbook/generics.html](https://www.typescriptlang.org/docs/handbook/generics.html)\n* [https://www.typescriptlang.org/docs/handbook/interfaces.html](https://www.typescriptlang.org/docs/handbook/interfaces.html)",
  },
  {
    question: "В чем разница между `.call` и `.apply`?",
    answer:
      "**Сходство заключается в том, что и .call, и .apply используются для вызова функций, а также первый параметр будет использоваться как значение this внутри функции. А разница в том, что .call в качестве следующих аргументов принимает аргументы, разделенные запятыми, в то время как .apply в качестве следующих аргументов принимает массив аргументов.**\nФункции в JavaScript никак не привязаны к своему контексту this, с одной стороны, здорово – это позволяет быть максимально гибкими, одалживать методы и так далее.\nНо с другой стороны – в некоторых случаях контекст может быть потерян. Способы явно указать this - методы bind, call и apply.",
  },
  {
    question: "Cors",
    answer:
      "_CORS_ расшифровывается как _Cross-Origin Resource Sharing_. Это механизм браузера, который позволяет определить список ресурсов, к которым страница может получить доступ. Он нужен для обеспечения безопасности и защиты пользователей от злоумышленников при использовании [HTTP-протокола](https://doka.guide/tools/http-protocol/).\nCross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. Говорят, что агент пользователя делает запрос с другого источника (cross-origin HTTP request), если источник текущего документа отличается от запрашиваемого ресурса доменом, протоколом или портом. \nCors - политика безопасности сервера, при которой доступ дается разрешенному домену\nCORS (Cross-Origin Resource Sharing) нужен для того, чтобы браузеры могли безопасно выполнять запросы к ресурсам на других доменах. Это важный механизм безопасности, который помогает предотвратить несанкционированный доступ к данным.",
  },
  {
    question: "REST",
    answer:
      "REST (Representational State Transfer) — это способ создания API с помощью протокола HTTP.\nRest Api - формат, подразумевающий себя клиент-серверное взаимодействие. В качестве формата используется Джейсон.\nНа сервере существует набор ендпойнтов, по которым мы можем пройзводить действия с данными с помощью методов пост, гет, пут и делит запросов. Чаще всего подразумевает взаимодействие по http - протоколу прикладного уровня, для обмена данными.\nСодержит в себе заголовки строку запроса тело и метод.",
  },
  {
    question: "Мемоизация",
    answer:
      "Прием создания функции, способной запоминать ранее вычисленные результаты или значения. Преимущество мемоизации заключается в том, что мы избегаем повторного выполнения функции с одинаковыми аргументами. Недостатком является то, что мы вынуждены выделять дополнительную память для сохранения результатов.",
  },
  {
    question: "Прототипом наследование ",
    answer:
      "прототип — это план (схема или проект) объекта. Он используется как запасной вариант для свойств и методов, существующих в данном объекте. Это также один из способов обмена свойствами и функциональностью между объектами. Это основная концепция прототипного наследования в JS.\nПри обращённую к свойству объекта, сначала происходит поиск свойства самого объекта, а если не находит то ищет в прототипе.\nОбъекты в JavaScript можно организовать в цепочки так, чтобы свойство, не найденное в одном объекте, автоматически искалось бы в другом. Связующим звеном выступает специальное свойство __proto__\nЕсли определенного свойства нет в объекте, его поиск осуществляется сначала в прототипе объекта, затем в прототипе прототипа объекта и так до тех пор, пока свойство не будет найдено. Это называется цепочкой прототипов. На вершине цепочки прототипов находится Object.prototype.",
  },
  {
    question: "Операции над типами в TypeScript",
    answer:
      "TypeScript предоставляет множество операций над типами, которые позволяют вам создавать новые типы данных, манипулировать существующими типами и повышать гибкость вашего кода. \n**Основные операции:**\n* Пересечение типов (&): Создает новый тип, который содержит свойства из обоих типов. \n```\n    interface User {\n      name: string;\n    }\n\n    interface Product {\n      price: number;\n    }\n\n    type UserWithPrice = User & Product; \n    // UserWithPrice имеет свойства name и price\n```\n\n* Объединение типов (|): Создает новый тип, который может быть одним из нескольких типов.\n```\n    type Id = number | string;\n    // id может быть как числом, так и строкой\n```\n\n* Условные типы (T extends U ? X : Y): Создает новый тип, который зависит от условия, проверяющего, является ли тип T подтипом U. \n```\n    type IsString<T> = T extends string ? true : false;\n    // IsString<string> будет true, IsString<number> будет false\n```\n\n* Ключевые операции:  \n    * `keyof`: Возвращает тип, представляющий все ключи объекта.\n    * `typeof`: Возвращает тип объекта, функции или переменной.\n    * `typeof` с функциями: Возвращает тип возвращаемого значения функции.\n    * `Partial<T>`: Создает тип, который является частичной версией T, где все свойства являются необязательными.\n    * `Required<T>`: Создает тип, который является обязательной версией T, где все свойства являются обязательными.\n    * `Readonly<T>`: Создает тип, который является только для чтения версией T, где все свойства не могут быть изменены.\n\nСсылки для детального изучения:\n\n* [https://www.typescriptlang.org/docs/handbook/advanced-types.html](https://www.typescriptlang.org/docs/handbook/advanced-types.html)\n* [https://www.typescriptlang.org/docs/handbook/utility-types.html](https://www.typescriptlang.org/docs/handbook/utility-types.html) \n* [https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#keyof](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#keyof) (Ключевое слово keyof)",
  },
  {
    question: "Из чего состоит HTTP запрос",
    answer:
      "- Метод запроса (Request Method): Определяет тип операции, которую клиент хочет выполнить на сервере. Некоторые распространенные методы запроса включают GET, POST, PUT, DELETE и HEAD.\n- Заголовки (Headers): Представляют собой метаданные, которые передаются вместе с запросом и содержат дополнительную информацию о запросе, такую как тип содержимого, аутентификация, кеширование и другие параметры.\n- Тело запроса (Request Body): Используется только в некоторых методах запроса, таких как POST или PUT. Оно содержит данные, которые клиент отправляет на сервер, например, форму для отправки или JSON-объект.",
  },
  {
    question: "Полифил",
    answer:
      "Полифил — код, реализующий какую-либо функциональность, которая не поддерживается в некоторых версиях веб-браузеров.  \nПолифил — это фрагмент кода (в сети — обычно JavaScript), который позволяет использовать современную функциональность в более старых браузерах, которые не поддерживают ее по умолчанию.",
  },
  {
    question: "Оптимизация",
    answer:
      "- Сжатие медиафайлов\n- Кеширование на сервере\n- Code spliting с помощью webpack\n- Lazy Loading\n- Чистка кода, мемоизация методов, оптимизация работы кода\n- Серверный рендеринг",
  },
  {
    question: "Базовые принципы ООП",
    answer:
      "- Абстракция — отделение концепции от ее экземпляра;\n- Полиморфизм — реализация задач одной и той же идеи разными способами;\n- Наследование — способность объекта или класса базироваться на другом объекте или классе. Это главный механизм для повторного использования кода. Наследственное отношение классов четко определяет их иерархию;\n- Инкапсуляция — размещение одного объекта или класса внутри другого для разграничения доступа к ним.",
  },
  {
    question: "SOLID Principles",
    answer:
      '**SOLID Principles** — это пять основных принципов объектно-ориентированного проектирования, которые помогают создавать гибкий, поддерживаемый и масштабируемый код.  \n1. **Single Responsibility (Принцип единственной ответственности)**  \n   Каждый класс должен иметь только одну причину для изменения, то есть решать одну задачу. Например, класс `User` должен отвечать только за данные пользователя, а логику отправки email лучше вынести в отдельный класс `EmailService`.  \n2. **Open/Closed (Принцип открытости/закрытости)**  \n   Классы должны быть открыты для расширения, но закрыты для модификации. Это значит, что новую функциональность следует добавлять через наследование или композицию, а не изменяя существующий код. Например, вместо правки класса `PaymentProcessor` для поддержки новых способов оплаты, можно создать интерфейс `PaymentMethod` и добавлять реализации (`CreditCard`, `PayPal`).  \n3. **Liskov Substitution (Принцип подстановки Барбары Лисков)**  \n   Наследующие классы должны корректно работать вместо родительских. Если у вас есть класс `Bird` с методом `fly()`, то его подкласс `Penguin` не должен нарушать логику программы, поскольку пингвины не летают.  \n4. **Interface Segregation (Принцип разделения интерфейсов)**  \n   Клиенты не должны зависеть от методов, которые они не используют. Лучше создавать узкоспециализированные интерфейсы вместо одного "толстого". Например, вместо `IMachine` с методами `print()`, `scan()`, `fax()`, лучше сделать отдельные `IPrinter`, `IScanner`.  \n5. **Dependency Inversion (Принцип инверсии зависимостей)**  \n   Модули высокого уровня не должны зависеть от модулей низкого уровня — оба должны зависеть от абстракций. Например, класс `OrderService` должен работать с интерфейсом `PaymentGateway`, а не с конкретной реализацией `StripePayment`.  \n**Итог:** SOLID помогает избегать спагетти-кода, упрощает тестирование и делает систему устойчивой к изменениям.',
  },
  {
    question: "Всплытие переменных (Hoisting)",
    answer:
      "Всплытие переменных — это особенность JavaScript, которая позволяет объявлять переменные в любой части функции, но фактически они поднимаются наверх функции перед выполнением кода.\nКак это работает:\n* var: Переменные, объявленные с помощью var, \"всплывают\" наверх функции, но их значение остается неопределенным (undefined) до момента выполнения строки кода, где они инициализируются.\n* let и const: Переменные, объявленные с помощью let и const, тоже всплывают, но их значение не инициализируется до момента доступа к ним. Попытка обратиться к неинициализированной переменной let или const приведет к ошибке.\n\nПримеры:\n```\nconsole.log(myVar); // undefined\nvar myVar = 'Hello'; \n\nconsole.log(myLet); // ReferenceError: Cannot access 'myLet' before initialization\nlet myLet = 'World'; \n```\nВажно:\n* let и const: Переменные, объявленные с помощью let и const, являются более безопасными, так как они не допускают неявное инициализацию переменных, что может привести к ошибкам.\n\nСсылки для детального изучения:\n* [https://developer.mozilla.org/en-US/docs/Glossary/Hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)\n* [https://javascript.info/hoisting](https://javascript.info/hoisting)",
  },
  {
    question:
      "Порядок работы браузера от момента клика по ссылке и до полной загрузки страницы:",
    answer:
      "Жизненный цикл HTTP-запроса представляет собой последовательность этапов, которые происходят при отправке HTTP-запроса от браузера к серверу и получении ответа. Давайте рассмотрим подробно каждый этап:\n\n1. Разрешение DNS:\n2. Установление TCP-соединения с сервером\n3. Отправка HTTP-запроса:\nБраузер формирует HTTP-запрос, который содержит метод (GET, POST, PUT и другие), путь к запрашиваемому ресурсу (URI), версию протокола HTTP и другие заголовки.\nЗапрос может также содержать тело, в случае POST-запроса, когда данные отправляются на сервер.\nБраузер отправляет сформированный HTTP-запрос по установленному TCP-соединению на сервер.\n4. Обработка запроса на сервере:\nСервер получает HTTP-запрос от браузера.\nСервер анализирует метод запроса, путь к запрашиваемому ресурсу и другие заголовки, чтобы определить, какой обработчик должен обрабатывать запрос.\nОбработчик сервера выполняет необходимые операции, такие как поиск или генерация данных, взаимодействие с базой данных, выполнение бизнес-логики и т.д.\n5. Формирование и отправка HTTP-ответа:\nСервер формирует HTTP-ответ: код состояния, заголовки и тело ответа (если есть).\nТело ответа может содержать HTML-код, изображения, JSON-данные и другие данные, в зависимости от запроса.\nСформированный HTTP-ответ отправляется обратно в браузер через установленное TCP-соединение.\n6. Получение и обработка HTTP-ответа:\nБраузер получает HTTP-ответ от сервера.\nЕсли ответ содержит HTML-код, браузер начинает процесс рендеринга страницы.\nБраузер интерпретирует HTML-код и создает DOM (Document Object Model) - дерево объектов, представляющее структуру страницы.\nCSS-стили, указанные в ответе или связанные с документом, применяются к элементам DOM, что позволяет задать внешний вид и расположение элементов на странице.\nJavaScript-код, если есть, выполняется, обеспечивая дополнительную интерактивность и функциональность на странице.\nБраузер отображает контент на экране пользователя, включая текст, изображения, формы, ссылки и другие элементы, соответствующие заданным стилям.\n7. Закрытие соединения:\nПосле завершения обработки и отображения ответа, браузер может закрыть TCP-соединение с сервером.\nОднако, соединение может быть оставлено открытым для повторного использования, если на странице присутствуют дополнительные ресурсы, такие как изображения или скрипты, которые должны быть загружены.\n\nСсылки для детального ознакомления:\n• [Официальный сайт MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP)\n• [Статья о жизненном цикле HTTP-запроса](https://www.tutorialrepublic.com/web-development-tutorials/http-request-life-cycle.php)",
  },
  {
    question: "Deeplink",
    answer:
      "**Deeplink** — это гиперссылка, которая перенаправляет пользователя в конкретный раздел приложения или сайта. Эта функция сокращает количество промежуточных действий пользователя и помогает ему попасть на нужную страницу за минимальное количество кликов.\nДиплинки умеют:\n- Перенаправлять пользователя в приложение на смартфоне — а не на страницу в браузере, по факту попадания на которую он не сможет совершить какие-либо действия.\n- Собирать статистику по переходам, кликам и посетителям.\n- Перенаправлять пользователя сразу в нужный раздел на сайте, а не на главную страницу.\n- Индексироваться в поисковых системах.\n- Легко встраиваться в QR коды.",
  },
  {
    question: "Когда вызывается `useLayoutEffect` в React?",
    answer:
      "`useLayoutEffect` выполняется **после рендеринга компонента, но до отрисовки (paint) в браузере**. Это делает его полезным для работы с DOM, когда важно, чтобы изменения произошли синхронно до того, как пользователь увидит результат.  \n**Этап жизненного цикла, на котором срабатывает `useLayoutEffect`** \n1. **Рендер компонента** (выполнение JSX и виртуального DOM).  \n2. **Вызов `useLayoutEffect`** (синхронно, блокирует отрисовку).  \n3. **Обновление реального DOM** (если были изменения).  \n4. **Браузер отрисовывает (paint) изменения**.  \n5. **Вызов `useEffect`** (асинхронно, после отрисовки).  \nСравнение с `useEffect`\n\n| Характеристика        | `useLayoutEffect`         | `useEffect`                             |     |\n| --------------------- | ------------------------- | --------------------------------------- | --- |\n| **Время выполнения**  | До отрисовки (синхронно)  | После отрисовки (асинхронно)            |     |\n| **Использование**     | Измерение/изменение DOM   | Запросы API, подписки, побочные эффекты |     |\n| **Влияние на рендер** | Может задержать отрисовку | Не блокирует отрисовку                  |     |\nПример использования `useLayoutEffect`  \n```javascript\nimport { useLayoutEffect, useState, useRef } from 'react';\n\nfunction Tooltip() {\n  const [width, setWidth] = useState(0);\n  const ref = useRef();\n\n  useLayoutEffect(() => {\n    // Измеряем ширину элемента ДО того, как пользователь увидит страницу\n    setWidth(ref.current.offsetWidth);\n  }, []);\n\n  return <div ref={ref}>{width}</div>;\n}\n```\nКогда выбирать `useLayoutEffect`?\n- Нужно изменить DOM до отрисовки (например, скорректировать позицию тултипа).  \n- Требуется синхронное обновление (чтобы избежать \"мерцания\" при рендере).  \nКогда выбирать `useEffect`?\n- Асинхронные операции (запросы к API, таймеры).  \n- Действия, не требующие блокировки отрисовки.  \n**Важно:** В большинстве случаев достаточно `useEffect`. `useLayoutEffect` нужен только для специфичных сценариев работы с DOM.",
  },
  {
    question: "Дженерики",
    answer:
      'Дженерики в тс - Дженерики — переменные, через которые мы можем передавать тип.\n"дженерики — это возможность создавать компоненты, работающие не только с одним, а с несколькими типами данных".',
  },
  {
    question: "Service workers",
    answer:
      "Service workers - это скрипт, который браузер запускает в фоновом режиме, отдельно от страницы, открывая дверь для возможностей, не требующих веб-страницы или взаимодействия с пользователем. \nСервис-воркер – это скрипт, который работает в фоновом режиме, независимо от веб-страницы. Он позволяет выполнять задачи, которые не требуют взаимодействия с пользователем или даже находиться в активной вкладке браузера. Некоторые из основных возможностей сервис-воркеров включают:\n- Кеширование ресурсов для работы в офлайн-режиме\n- Получение и отправка push-уведомлений\n- Синхронизация данных в фоновом режиме",
  },
  {
    question: "Как работает виртуальный DOM:",
    answer:
      "VirtualDOM - это копия DOM дерева и вместо того, чтобы взаимодействовать с DOM напрямую, мы работаем с его легковесной копией. Мы можем вносить изменения в копию, исходя из наших потребностей, а после этого React применяет изменения к реальному DOM. При этом происходит сравнение DOM-дерева с его виртуальной копией, определяется разница и запускается перерисовка того, что было изменено. Такой подход работает быстрее, потому как не включает в себя все тяжеловесные части реального DOM.\nKey помогает React определять, какие элементы были изменены, добавлены или удалены. Key нужен для лучшего определения порядка элементов в списке. \nReact.Fragment не создает узел в DOM дереве, из за этого наш DOM будет чуть-чуть меньше и не будет содержать элементов ради элементов.\n\nВиртуальный DOM - это облегченная копия реального DOM, представленная в памяти. React использует его для оптимизации рендеринга. \nГлавный момент в алгоритме обновления Virtual DOM состоит в том что react следит за выполнением нескольких условий для того чтобы не перерисовывать компонент:\n- это элемент того же типа\n- элемент расположен на том же месте в dom\n- элемент имеет тот же key\n\nСсылки для детального ознакомления:\n• [Документация React о виртуальном DOM](https://reactjs.org/docs/reconciliation.html)\n• [Статья о виртуальном DOM в React](https://www.freecodecamp.org/news/how-does-react-virtual-dom-work-and-why-should-you-care/)",
  },
  {
    question: "Хранилища в браузере",
    answer:
      "**IndexedDB**\n  - Асинхронный API браузера.\n  - Предоставляет возможность хранить большие объемы структурированных данных на стороне клиента.\n  - Позволяет создавать базы данных с таблицами, индексами и транзакциями, что делает его похожим на традиционные реляционные базы данных.\n**LocalStorage:**\n  * Используется для хранения небольших объемов данных (до 5 МБ) на стороне клиента.\n  * Доступно только для домена, который его создал.\n  * Данные сохраняются даже после закрытия браузера.\n**SessionStorage:**\n  * Аналогично LocalStorage, но данные хранятся только в течение текущей сессии браузера.\n  * Данные удаляются при закрытии браузера или при закрытии вкладки.\n**Cookies:**\n  * Небольшие текстовые файлы, которые отправляются сервером и хранятся браузером.\n  * Используются для хранения небольших объемов данных, например, идентификаторов сессии или настроек пользователя.\n  * Доступны для всех доменов, которые установили их.\n\n![[telegram-cloud-photo-size-2-5233340281091385407-y.jpg]]",
  },
  {
    question:
      "Разница [Map](https://learn.javascript.ru/set-map#map) и [Set](https://learn.javascript.ru/set-map#set)",
    answer:
      "`Map` — коллекция для хранения записей вида `ключ:значение`.\nВ отличие от объектов, в которых ключами могут быть только строки, в `Map` ключом может быть произвольное значение, например:\n\n`Set` — коллекция для хранения множества значений, причём каждое значение может встречаться лишь один раз.\nНапример, к нам приходят посетители, и мы хотели бы сохранять всех, кто пришёл. При этом повторные визиты не должны приводить к дубликатам, то есть каждого посетителя нужно «посчитать» ровно один раз.",
  },
  {
    question: "Циклы [[for in for of]], особенности, в чем разница",
    answer: "",
  },
  {
    question: "[[TypeScript Utility Types|ts omit partial generics]]",
    answer:
      "Тайпскрипт предоставляет несколько утилит для трансформации уже имеющихся типов, например\n- `Partial<Type>`\n- `Required<Type>`\n- `Omit<Type, Keys>`",
  },
  {
    question: "getStaticProps",
    answer:
      " - **getStaticProps** – метод, указывающий Next-компоненту выполнить внутреннюю логику и потом передать полученные данные (пропы) и прорендерить себя во время процесса сборки приложения. Рендеринг на этапе сборки с помощью **getStaticProps()** означает, что перед размещением компонента Next.js преобразует React в стандартные HTML-страницы, и только после этого они размещаются на хостинге и предоставляются клиенту.  ",
  },
  {
    question: "getServerSideProps",
    answer:
      '**- getServerSideProps** - метод, указывающий Next-компоненту выполнить внутреннюю логику и потом передать полученные данные (пропы) и прорендерить себя во время так называемого рантайма. В отличии от статической генерации через **getStaticProps()**, где HTML генерируется всего один раз и сохраняется для последующих запросов, **getServerSideProps()** предусматривает создание серверной прослойки на каждый запрос страницы. В таком случае логика внутри метода, передача пропов и частичный рендеринг компонента происходят на стороне сервера на каждый запрос клиентской частью. После обработки на сервере клиент получает базовый неинтерактивный HTML, а также получает JSON-объект пропов и JavaScript-инструкции для добавления интерактивности компоненту. После чего происходит так называемый процесс "гидрации" – выполнения минимального сета инструкций на клиентской части для получения полноценного интерактивного компонента.',
  },
  {
    question: "Intersection Observer",
    answer:
      "_Intersection Observer_ — браузерный API, который позволяет асинхронно отслеживать пересечение элемента с его родителем или областью видимости документа (viewport). В момент пересечения можно запустить какое-либо действие, например, подгрузить дополнительные посты в ленте новостей («бесконечный скролл») или сделать «ленивую» загрузку контента.",
  },
  {
    question: "Реконсилиация",
    answer:
      "Реконсилиация — алгоритм, используемый React-ом, чтобы вычислить разницу между двумя деревьями для определения того, какие части должны быть обновлены.",
  },
  {
    question: "Версии http протокола разница",
    answer:
      "Первая версия протокола http требовала дожидаться получения ответа перед отправлением следующего запроса в рамках одного соединения. Во второй версии протокола - это исправили, соединение может использоваться без ожидания завершения уже отправленного запроса.\n**HTTP/2** 🚀 – это обновлённая версия интернет-протокола, которая делает загрузку веб-страниц **быстрее и эффективнее**. Она позволяет отправлять много запросов одновременно через одно соединение, уменьшает задержки и делает интернет-сёрфинг более гладким.\n**HTTP/2** решает проблему медленной загрузки веб-страниц, которая была характерна для предыдущей версии протокола. Благодаря **мультиплексированию** и **сжатию заголовков**, веб-страницы теперь загружаются значительно быстрее, что особенно заметно на мобильных устройствах с нестабильным интернет-соединением.",
  },
  {
    question: "Дебаунс",
    answer:
      "Дебаунс выполнится один раз через какое то колличество секунд, а тротл будет выполняться постоянно через заданное колличество милисекунд - Таймслайсинг",
  },
];
